---
title: 'C칩mo gestionar el estado de Angular en sus componentes'
date: "2020-11-27"
description: "En este tutorial, explicar칠 c칩mo gestionar el estado de tus componentes con @ngrx/component-store."
canonical_url: https://indepth.dev/posts/1408/how-to-manage-angular-state-in-your-components
category: 'Angular'
---

Actualizado el 3 de diciembre de 2020

Gracias [@AlexOkrushko](https://twitter.com/AlexOkrushko) y [@Nartc1410](https://twitter.com/Nartc1410) por el gran comentario.

Gestionar el estado de tu aplicaci칩n Angular siempre ha sido un reto.

En este tutorial, explicar칠 c칩mo gestionar el estado de tu componente con `@ngrx/component-store`. Podr치s hacerlo de una forma m치s organizada y minimizando los bugs e inconsistencias de la UI.

### Tabla de contenido

- [Requisitos previos](#prerrequisitos)
- [쯈u칠 vamos a construir?](#what-are-go-to-build-)
- [쯈u칠 es el "estado"?](#what-is-the--state-)
- [No todas las aplicaciones Angular necesitan NgRx o NGSX](#not-all-angular-apps-need-ngrx-or-ngsx)
- [El problema](#the-problem)
- [La soluci칩n: @ngrx/component-store](#the-solution---ngrx-component-store)
    - [쮺u치ndo usar un @ngrx/store o un @ngrx/component-store?](#when-to-use-an--ngrx-store-or--ngrx-component-store-)
    - [Mi recomendaci칩n](#mi-recomendaci칩n)
    - [Conceptos de @ngrx/component-store](#ngrx-component-store-concepts)
- [Inicio](#getting-started)
    - [Inicializaci칩n de la aplicaci칩n](#initializing-the-application)
    - [Creaci칩n de utilidades](#creating-utilities)
    - [Definir el estado](#defining-the-state)
    - [Instalar @ngrx/component-store](#install--ngrx-component-store)
    - [Crear el servicio de tienda](#creating-the-store-service)
    - [Crear el componente de la lista de coches](#creating-the-car-list-component)
    - [A침adir el FormModule](#adding-the--formmodule-)
    - [Consumir el servicio de la tienda](#consuming-the-store-service)
    - [Eso es todo](#eso-es-eso)
    - [Resumen](#summary)
    - [Conclusi칩n](#conclusion)

## Requisitos previos

1. Conocimientos b치sicos de Angular
2. Conocimientos b치sicos de RXJS
3. Cuenta con [angular-cli](https://cli.angular.io/) instalado o [Stackblitz](https://stackblitz.com/)

## 쯈u칠 vamos a construir?

Una aplicaci칩n para gestionar el aparcamiento de coches y tendr치 las siguientes partes:

1. `store.service`: Donde gestionaremos todo nuestro estado y toda la l칩gica de la UI
2. `parking-lot.service`: Para comunicarnos con el backend (para la demo)
3. `app.component`: Componente padre. Consumimos el estado y a침adimos coches al parking
4. `car-list.component`: Para mostrar la lista de coches aparcados.

Si quieres, puedes saltar al [c칩digo fuente](https://stackblitz.com/edit/angular-component-store-tutorial), sin compromiso 游뱁 o directamente al [tutorial](#getting-started).

## 쯈u칠 es el "estado"?

Es la **representaci칩n de su UI** mediante un objeto, y podr칤amos cambiarlo de diferentes maneras, por ejemplo:

- Solicitud de redes
- Eventos del usuario
- Cambios en el router
- Entre otros

### Ejemplo:

```typescript
state = {
    cars: [],
    loading: true,
    error: '',
}
```

1. Lista de coches en el aparcamiento: `cars: []`
2. Para cambiar la UI de nuestra app mientras se realiza una operaci칩n que tarda en resolverse, por ejemplo, una petici칩n de red: `loading: true`.
3. Para mostrar los errores que puedan ocurrir durante la ejecuci칩n de la aplicaci칩n: `error: ''`

> Casi todos los componentes tienen un estado. Los manejamos indirectamente usando propiedades y cambi치ndolas durante su ciclo de vida.

### En resumen un estado es:

1. Es un objeto que representa la vista de tu componente
2. **No son los datos que vienen del servidor**, de hecho, esto puede ser parte de ellos
3. Puede tener tantos niveles como necesites
4. **Es inmutable**. Cuando necesitas actualizar una propiedad, no la cambias directamente sino que creas un nuevo objeto con la propiedad modificada.

## No todas las aplicaciones Angular necesitan NgRx o NGSX

La mayor칤a de las aplicaciones Angular **no necesitan un sistema de gesti칩n de estado completo**. Es mejor gestionar el estado a nivel de componente antes de implementar una soluci칩n m치s compleja a nivel de app como NgRx o NGSX.

<Image src="/static/images/blog/how-to-manage-angular-state-in-your-components/001-tweet.png" alt="No todas las aplicaciones Angular necesitan NgRx o NGSX" width="596" height="738" />

[Tweet Link](https://twitter.com/fmontes/status/1325430712816840705)

## El problema

Si tienes un [componente inteligente](https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/) con varios componentes hijos, probablemente tengas muchas propiedades en tu componente padre que necesitas pasar a los componentes hijos.

Seguro que los componentes hijos emiten eventos que cambiar치n las propiedades de su padre.

Mantener todos estos cambios en orden y bajo control puede convertirse en una tarea tediosa porque las propiedades cambian en muchos lugares que pueden ser dif칤ciles de rastrear, especialmente en tareas as칤ncronas.


## La soluci칩n: @ngrx/component-store

El mismo equipo de NgRx desarroll칩 [@ngrx/component-store](https://ngrx.io/guide/component-store). Un servicio basado en `ReplaySubject` puede extenderse a un servicio y ser consumido por un componente.

Permite mantener toda la l칩gica de negocio fuera del componente (o componentes) y s칩lo se suscribe al estado y actualiza la UI cuando cambia.

El servicio que creas al extender **ComponentStore** es 칰nico para un componente en particular y sus hijos y debe ser inyectado directamente en la propiedad `providers` del componente.

### 쮺u치ndo utilizar un @ngrx/store o un @ngrx/component-store?

En su aplicaci칩n, puede utilizar ambas. Ambas bibliotecas se complementan.

1. Si el estado **necesita persistir** cuando cambias la URL, ese estado va en tu **estado global
2. Si el estado **necesita ser limpiado** cuando cambias la URL, ese estado va en tu **almac칠n de componentes**.

M치s informaci칩n en [Comparaci칩n de ComponentStore y Store](https://ngrx.io/guide/component-store/comparison).

### Mi recomendaci칩n

Si **no tienes ninguna libreria para gestinar el estado** en tu app y quieres empezar con una, te recomiendo empezar con `@ngrx/component-store` y evaluar si necesitas algo m치s complicado en el futuro.

De esta forma, puedes empezar a implementar la gesti칩n de estados en partes de tu app y escalar de forma eficiente.

### Conceptos de @ngrx/component-store

S칩lo tiene tres conceptos muy sencillos que tienes que aprender:

1. **Selectores**: Seleccionas y te suscribes al estado, ya sea todo o parte de 칠l
2. **Actualizador**: Para actualizar el estado. Puede ser por partes o en su totalidad
3. **Efectos**: Es tambi칠n actualizar el estado pero hacer alguna otra tarea necesaria previamente. Por ejemplo, una petici칩n HTTP a una API

## Comenzando

La aplicaci칩n tendr치 una UI con tres secciones:

1. Formulario para a침adir el carrito
2. Tabla con los carros aparcados
3. Mensajes de error

<Image src="/static/images/blog/how-to-manage-angular-state-in-your-components/002-parking-lot-app-demo.gif" alt="Parking lot app demo" width="850" height="637" />

### Inicializaci칩n de la aplicaci칩n

El primer paso es crear una nueva aplicaci칩n Angular. Con [angular-cli](https://cli.angular.io/). Abre un terminal, ejecuta el comando

```shell
ng new parking-lot-app
```

Iniciamos la aplicaci칩n que hemos creado:

```shell
cd parking-lot-app
ng serve
```

A continuaci칩n, apunta tu navegador a [http://localhost:4200/](http://localhost: 4200/), y ver치s tu aplicaci칩n Angular funcionando con toda la informaci칩n por defecto.

### Creando utilidades

Lo primero que vas a crear es la interfaz **"Coche "**. Ejecuta el comando

```shell
ng g interface models/car
```

Abre el archivo `app/models/car.ts` y a침ade:

```typescript
export interface Car {
    plate: string
    brand: string
    model: string
    color: string
}
```

Lo anterior es el modelo muy b치sico del coche.

Entonces **creas un servicio** que se comunicar치 con el "backend" (s칩lo para la demo). Ejecutas el comando

```shell
ng g service services/parking-lot
```

Abre el archivo `app/services/parking-lot.service.ts` y a침ade:

```typescript
import { Injectable } from '@angular/core'
import { Observable, of, throwError } from 'rxjs'
import { delay } from 'rxjs/operators'
import { Car } from '../models/car'

const data: Car[] = [
    {
        plate: '2FMDK3',
        brand: 'Volvo',
        model: '960',
        color: 'Violet',
    },
    {
        plate: '1GYS4C',
        brand: 'Saab',
        model: '9-3',
        color: 'Purple',
    },
    {
        plate: '1GKS1E',
        brand: 'Ford',
        model: 'Ranger',
        color: 'Indigo',
    },
    {
        plate: '1G6AS5',
        brand: 'Volkswagen',
        model: 'Golf',
        color: 'Aquamarine',
    },
]

const FAKE_DELAY = 600

@Injectable({
    providedIn: 'root',
})
export class ParkingLotService {
    private cars: Car[] = []

    constructor() {}

    add(plate: string): Observable<Car> {
        try {
            const existingCar = this.cars.find((eCar: Car) => eCar.plate === plate)

            if (existingCar) {
                throw `This car with plate ${plate} is already parked`
            }

            const car = this.getCarByPlate(plate)
            this.cars = [...this.cars, car]

            return of(car).pipe(delay(FAKE_DELAY))
        } catch (error) {
            return throwError(error)
        }
    }

    private getCarByPlate(plate: string): Car {
        const car = data.find((item: Car) => item.plate === plate)

        if (car) {
            return car
        }

        throw `The car with plate ${plate} is not register`
    }
}
```

Datos: Una lista de los coches registrados en nuestro sistema. Actuar치 como su base de datos de coches para la demo.

`FAKE_DELAY`: Para simular un peque침o retraso en la solicitud de la API utilizando el operador `delay` de `rxjs`.

**M칠todos:**

`add`: que recibe la matr칤cula del veh칤culo y si existe la a침ade a la lista de coches aparcados y si no devuelve un error.

`getCarByPlate`: este m칠todo privado s칩lo busca en nuestra "base de datos" (`data`) el coche con la matr칤cula, y si no existe, lanza un error.

**Propiedades

`car`: Para llevar la cuenta de los coches aparcados en el "backend".

### Definir el estado

Para definir el estado, veamos los requisitos de la aplicaci칩n:

1. El usuario a침adir치 coches por matr칤cula (una petici칩n a una API)
2. Debe indicar al usuario los errores:
    - La matr칤cula del veh칤culo no existe en la API
    - El veh칤culo ya est치 aparcado
3. Debe mostrar indicadores en la interfaz de usuario cuando se produce una solicitud
    - Cargar: cambiar el texto del bot칩n mientras ocurre la solicitud
    - Desactivar: el bot칩n y el campo de texto mientras ocurre la solicitud
    - Mostrar el error cuando se produce

En base a estos requisitos, el estado de su UI ser칤a el siguiente

```typescript
interface State {
    cars: Car[]
    loading: boolean
    error: string
}
```

1. Una lista de coches aparcados
2. Un `booleano` para cuando la aplicaci칩n hace una petici칩n
3. Una `cadena` para los mensajes de error

### Instalar @ngrx/component-store

Para a침adir `@ngrx/component-store` a tu aplicaci칩n utiliza `npm`:

```
npm install @ngrx/component-store --save
```

### Creaci칩n del servicio de tienda

Crea el archivo `app/store.service.ts` y a침ade el siguiente c칩digo:

```typescript
import { Injectable } from '@angular/core'
import { ComponentStore } from '@ngrx/component-store'
import { Car } from './models/car'

// The state model
interface ParkingState {
    cars: Car[] // render the table with cars
    error: string // show the error when try to add cars
    loading: boolean // used to enable/disable elements in the UI while fetching data
}

@Injectable()
export class StoreService extends ComponentStore<ParkingState> {
    constructor() {
        super({
            cars: [],
            error: '',
            loading: false,
        })
    }
}
```

Este c칩digo es la base de su `StoreService`:

1. Has importado `Injectable` (como cualquier otro servicio) y `ComponentStore`.
2. Has creado una interfaz `ParkingState` que define el estado de tu componente
3. Has creado la clase `StoreService` que extiende de `ComponentStore` y pasa la interfaz
4. Has inicializado el estado de la UI a trav칠s del constructor, haciendo que el estado est칠 disponible inmediatamente para los consumidores de `ComponentStore`.

Ahora vas a a침adir el resto del c칩digo, **selectos, actualizadores y efectos**. Tu c칩digo de servicio ser칤a:

```typescript
import { Injectable } from '@angular/core'

import { ComponentStore } from '@ngrx/component-store'
import { EMPTY, Observable } from 'rxjs'
import { catchError, concatMap, finalize, tap } from 'rxjs/operators'
import { Car } from './models/car'
import { ParkingLotService } from './services/parking-lot.service'

// The state model
interface ParkingState {
    cars: Car[] // render the table with cars
    error: string // show the error when try to add cars
    loading: boolean // used to enable/disable elements in the UI while fetching data
}

@Injectable()
export class StoreService extends ComponentStore<ParkingState> {
    constructor(private parkingLotService: ParkingLotService) {
        super({
            cars: [],
            error: '',
            loading: false,
        })
    }

    // SELECTORS
    readonly vm$: Observable<ParkingState> = this.select((state) => state)

    // UPDATERS
    readonly updateError = this.updater((state: ParkingState, error: string) => {
        return {
            ...state,
            error,
        }
    })

    readonly setLoading = this.updater((state: ParkingState, loading: boolean) => {
        return {
            ...state,
            loading,
        }
    })

    readonly updateCars = this.updater((state: ParkingState, car: Car) => {
        return {
            ...state,
            error: '',
            cars: [...state.cars, car],
        }
    })

    // EFFECTS
    readonly  = this.effect((plate$: Observable<string>) => {
        return plate$.pipe(
            concatMap((plate: string) => {
                this.setLoading(true)
                return this.parkingLotService.add(plate).pipe(
                    tap({
                        next: (car) => this.updateCars(car),
                        error: (e) => this.updateError(e),
                    }),
                    finalize(() => {
                        this.setLoading(false)
                    }),
                    catchError(() => EMPTY)
                )
            })
        )
    })
}
```

Es bastante c칩digo, as칤 que os lo explicar칠 por partes y empezar칠 por los selectores.

#### Selectores

Para crear un selector, se utiliza el m칠todo `select` de la siguiente manera:

```typescript
readonly vm$: Observable<ParkingState> = this.select(state => state);
```

El m칠todo `select` espera una funci칩n que reciba el estado completo. Con este estado, podemos devolver a los componentes lo que se necesita; en este caso, devuelve el estado completo.

En esta aplicaci칩n, se necesita un selector, pero se puede tener m치s de uno.

#### Actualizadores

Para actualizar el estado, necesitar치s tres actualizadores:

1. Para a침adir o eliminar el mensaje de error
2. Para actualizar la carga
3. Para a침adir coches al aparcamiento

Para crear actualizadores, utiliza el m칠todo `update` proporcionado por la clase `ComponentStore`.

El m칠todo recibe una funci칩n con dos par치metros, el primero es el estado actual, y el segundo es la carga 칰til que el componente envi칩 para actualizar el estado. Este m칠todo s칩lo tiene que devolver el nuevo estado.

##### Error y loading

```typescript
readonly updateError = this.updater((state: ParkingState, error: string) => {
    return {
        ...state,
        error
    };
});

readonly setLoading = this.updater(
    (state: ParkingState, loading: boolean) => {
        return {
            ...state,
            loading
        };
    }
);
```

El `updateError` recibe el mensaje de error y utiliza el operador [spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) para combinarlo con el estado anterior y devolver el nuevo estado.

El `setLoading` funciona igual que el anterior pero con la propiedad `loading`.

##### A침adir coches al parking

Este actualizador recibe un coche y simplemente lo a침ade al array de coches utilizando el operador spread.

```typescript
readonly updateCars = this.updater((state: ParkingState, car: Car) => {
    return {
        ...state,
        error: '',
        cars: [...state.cars, car],
    };
});
```

**IMPORTANTE**: Cuando se actualiza el estado, no se muta el objeto (cambiando alguna propiedad directamente) sino que se devuelve un nuevo objeto siempre.

#### Efectos

Para a침adir un coche al aparcamiento, hay que crear un `efecto` porque hay que hacer una petici칩n a una API con la matr칤cula del coche, y cuando responde, se actualiza el estado.

Para crear los efectos utilizamos el m칠todo `effect` que recibe un callback con el valor que le pasamos como **Observable**. Ten en cuenta que cada nueva llamada del efecto empujar칤a el valor a ese Observable.

```typescript
readonly addCarToParkingLot = this.effect((plate$: Observable<string>) => {
    return plate$.pipe(
        concatMap((plate: string) => {
            this.setLoading(true);
            return this.parkingLotService.add(plate).pipe(
                tap({
                    next: car => this.updateCars(car),
                    error: e => this.updateError(e)
                }),
                finalize(() => {
                    this.setLoading(false);
                }),
                catchError(() => EMPTY)
            );
        })
    );
});
```

En este c칩digo, se puede ver que el `efecto`:

1. Recibe la matr칤cula del coche como un `Observable`.
2. Actualizar el estado de `loading`.
3. Solicitar a la API que a침ada el coche al aparcamiento mediante el `ParkingLotService`.
4. Cuando la solicitud tenga 칠xito, actualiza el estado de nuevo: elimina la carga y a침ade el carro al estado.
5. Si falla: quitar la carga y actualizar el estado con el error que viene del "backend"

Usar `concatMap` para que si el `effect` es llamado varias veces antes de que termine la llamada, resuelva todas las llamadas. Este operador RxJS esperar치 hasta que la petici칩n anterior se complete para hacer la siguiente.

El operador `tap` para manejar el caso de 칠xito y error.

Y el operador `catchError` para manejar posibles errores dentro de la tuber칤a interna.

### Creando el componente `<car-list>`

Ejecuta el siguiente comando para generar el componente.

```shell
ng g component components/car-list
```

En el archivo `components/car-list.component.ts`, a침ade el siguiente c칩digo:

```typescript
import { Component, Input } from '@angular/core'
import { Car } from '../../models/car'

@Component({
    selector: 'app-car-list',
    templateUrl: './car-list.component.html',
    styleUrls: ['./car-list.component.css'],
    providers: [],
})
export class CarListComponent {
    @Input() cars: Car[] = []

    constructor() {}
}
```

En el archivo `components/car-list.component.html`, a침ade el siguiente c칩digo:

```html
<table *ngIf="cars.length; else noCars">
    <tr>
        <th>Plate</th>
        <th>Brand</th>
        <th>Model</th>
        <th>Color</th>
    </tr>
    <ng-template ngFor let-car [ngForOf]="cars" let-i="index">
        <tr>
            <td>{{car.plate}}</td>
            <td>{{car.brand}}</td>
            <td>{{car.model}}</td>
            <td>{{car.color}}</td>
        </tr>
    </ng-template>
</table>

<ng-template #noCars>
    <p>No cars in the parking lot</p>
</ng-template>
```

En el `components/car-list.component.css` hacemos que la tabla se vea elegante:

```css
table {
    width: 100%;
    border-collapse: collapse;
}

td,
th {
    border: solid 1px lightgray;
    padding: 0.5rem;
    text-align: left;
    width: 25%;
}

th {
    border-bottom-width: 3px;
}

p {
    text-align: center;
}
```

Por 칰ltimo, aseg칰rate de que el componente `car-list` est치 a침adido al m칩dulo.

Abre el archivo `app/app.module.ts`, mira en el array `declarations`, y si no est치 ah칤, puedes a침adir la clase `CarListComponent` manualmente.

### A침adiendo el `FormModule`

Como vas a tener un peque침o formulario con `[(ngModel)]` en el `app.component`, debes a침adir el `FormModule` al `app.module`.

Abre el archivo `app/app.module.ts` y a침ade el `FormsModule` al array `imports`. El c칩digo final se ve as칤:

```typescript
import { BrowserModule } from '@angular/platform-browser'
import { NgModule } from '@angular/core'

import { AppComponent } from './app.component'
import { CarListComponent } from './components/car-list/car-list.component'
import { FormsModule } from '@angular/forms'

@NgModule({
    declarations: [AppComponent, CarListComponent],
    imports: [BrowserModule, FormsModule],
    bootstrap: [AppComponent],
})
export class AppModule {}
```

### Consumir el servicio de la tienda

Has creado el servicio espec칤ficamente para la `app.component` y sus hijos.

#### `app/app.component.ts`

A침adir reemplazar todo el c칩digo con:

```typescript
import { Component } from '@angular/core'
import { StoreService } from './store.service'

@Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css'],
    providers: [StoreService],
})
export class AppComponent {
    plate = ''
    vm$ = this.store.vm$

    constructor(private store: StoreService) {}

    onSubmit($event: Event) {
        $event.preventDefault()
        this.store.addCarToParkingLot(this.plate)
    }

    addPlate($event: Event) {
        const target = $event.target as HTMLButtonElement

        if (target.nodeName === 'BUTTON') {
            this.plate = target.innerHTML
        }
    }
}
```

El `StoreService` maneja toda la l칩gica de negocio, lo que resulta en un componente diminuto. Veamos el c칩digo parte por parte:

##### Proveedores

`proveedores: [StoreService]`: Se inyecta el servicio a nivel de componente para que esta instancia s칩lo tenga este componente y sus hijos.

##### Propiedades

`plate`:  Para el modelo de formulario, el usuario introducir치 la matr칤cula del coche a a침adir al aparcamiento.

`vm$` Es el estado observable de nuestro `StoreService` y se actualiza cada vez que el estado cambia. Nos suscribiremos a esto en el HTML en el siguiente paso.

##### M칠todos

`constructor(private store: StoreService) {}`: Inyectas el `StoreService` en el constructor, como un servicio normal.

`onSubmit()`: Lo llamas cuando se env칤a el formulario, y lo 칰nico que hace es llamar al m칠todo del store `addCarToParkingLot` (efecto) con la matr칤cula del coche introducida por el usuario en el formulario.

El m칠todo `addPlate()`: Este m칠todo no es necesario, pero por motivos de demostraci칩n, lo he a침adido para introducir algunas matr칤culas pulsando unos botones.

#### `app/app.component.html`

A침adir reemplazar todo el c칩digo con:

```html
<header>
    <h1>Parking Lot Control</h1>
</header>

<ng-container *ngIf="vm$ | async as vm">
    <div class="messages">
        <p class="error" *ngIf="vm.error">{{vm.error}}</p>
    </div>

    <div class="box">
        <form (submit)="onSubmit($event)">
            <input
                type="text"
                [(ngModel)]="plate"
                [ngModelOptions]="{standalone: true}"
                placeholder="Ex: 2FMDK3, 1GYS4C, 1GKS1E,1G6AS5"
                [disabled]="vm.loading"
            />
            <button type="submit" [disabled]="vm.loading || !plate.length">
                <ng-container *ngIf="vm.loading; else NotLoading">
                    Loading...
                </ng-container>
                <ng-template #NotLoading>
                    Add Car
                </ng-template>
            </button>
        </form>
        <div class="shortcuts">
            <h5>Shortcuts</h5>
            <p (click)="addPlate($event)" class="examples">
                <button>2FMDK3</button>
                <button>1GYS4C</button>
                <button>1GKS1E</button>
                <button>1G6AS5</button>
            </p>
        </div>
    </div>

    <app-car-list [cars]="vm.cars"></app-car-list>
</ng-container>
```

`<ng-container *ngIf="vm$ | async as vm">`: Lo primero es obtener el ViewModel de la propiedad `vm$` que creamos en la clase componente, usamos `async` pipe para suscribirnos, y hacemos una variable est치tica `vm` que el resto de nuestro HTML podr치 usar.

###### Mensaje de error

El error es una `string`, por lo que s칩lo tenemos que mostrarlo en el HTML y utilizando la interpolaci칩n:

`<p class="error" *ngIf="vm.error">{{vm.error}}</p>`

###### Formulario

Creamos un formulario para que el usuario introduzca la matr칤cula del coche que quiere a침adir al aparcamiento, y enlazamos el evento `onSubmit`.

`<form (submit)="onSubmit()">`

Es un peque침o formulario con un campo de texto para que el usuario introduzca la matr칤cula y un bot칩n para ejecutar la acci칩n de a침adir.

`<input>`: Habilita/deshabilita en funci칩n de la propiedad `loading` del estado.

`<bot칩n>`: Se habilita/deshabilita con la propiedad `loading` del estado pero tambi칠n si la propiedad `plate` del componente est치 vac칤a (evita que se env칤e una `string` vac칤a al servicio de la tienda)

En el m칠todo `onSubmit` del componente, llamamos al efecto con el n칰mero de placa introducido por el usuario, y aqu칤 es donde nuestro servicio ComponentStore lo hace todo.

#### `app/app.component.css`

A침adimos algunos estilos para que nuestra aplicaci칩n se vea muy bien:

```css
h1 {
    margin-bottom: 0;
}

.box {
    border: solid 1px lightgrey;
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    margin-bottom: 1rem;
}

.box p {
    margin: 0;
}

.box form {
    display: flex;
}

.box form input {
    margin-right: 0.5rem;
}

.box form button {
    width: 80px;
}

.messages {
    height: 2.4rem;
    margin: 1rem 0;
}

.messages p {
    border: solid 1px transparent;
    margin: 0;
    padding: 0.5rem;
}

.messages .error {
    background-color: lightyellow;
    border: solid 1px red;
    color: red;
    text-align: center;
}

.examples button {
    border: 0;
    background: none;
    color: blue;
    text-decoration: underline;
    cursor: pointer;
    padding: 0;
    margin: 0 0.5rem 0 0;
}

.examples button:last-child {
    margin: 0;
}

.shortcuts h5 {
    margin: 0;
}

.code {
    margin-top: 3rem;
    border: solid 1px lightgray;
    padding: 1rem;
}

.code h4 {
    margin: 0 0 1rem;
}

.code pre {
    margin: 0;
}
```

Y en el archivo de estilo global `src/styles.css`:

```css
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial,
        sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
    margen: 3rem;
}
```

### Eso es todo

Ve a tu navegador: [https://localhost:4200](https://localhost:4200) y vea su aplicaci칩n funcionando.

### Resumen

1. Has creado un servicio que se comunica con la API: `ParkingLotService`.
2. Has creado un servicio que maneja toda la l칩gica y el estado del componente `StoreService` que extiende a `ComponentStore`.
3. Tu UI se suscribe al estado del `StoreService`, y cada vez que cambia, tu UI se actualiza.

Usando este enfoque, terminar치s con una 칰nica "fuente de verdad" para tu UI, f치cil de usar sin tener que cambiar el c칩digo en muchos lugares para actualizar o mejorar.

### Conclusi칩n

Como has podido ver, es mejor empezar a gestionar el estado a nivel de componente antes de saltar a una arquitectura completa.

Un estado es simplemente un objeto que representa el aspecto de tu interfaz, y utilizando `@ngrx/component-store` y sus tres conceptos b치sicos: `select`,`update` y `effect`, puedes manejarlo de una manera simple, directa y m치s indolora prueba.
